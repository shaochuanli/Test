package cn.tootoo.test;

public class NormalCreateOrder {
	
	
	// 校验是否登录
	
	// 校验支付密码;
	
	// 校验是否下单太快
	
	// 校验是否优惠券和兑换券同时存在
	
	// 将下单入参传入的商品列表纬度转换，从购买方式纬度转换为商品纬度的goodsCount，方便后面使用
	// 传入时 goodsId1-购买1个，goodsId2-购买2个，
	//				goodsId1-赠送2个，
	//				goodsId2-换购1个，
	// 转换后 goodsId1-购买1个、赠送2个、换购0个，
	//				goodsId2-购买2个、赠送0个、换购1个，
	

	// 调用商品服务(goods服务, getGoodsProps方法)
	// 目的:
	// 1、判断是否所有商品调用商品服务都有信息，如果不是return错误
	// 2、获取所有的商品是否是礼盒，如果是礼盒则获取它的明细


	// 调用商品服务(goods服务, getGoodsInfo方法)
	// 验证商品:
	// 1、判断是否所有商品调用商品服务都有返回信息
	// 2、判断是否所有商品都是上架状态
	// 3、判断是否所有的商品都属于同一个分站，并且是下单入参传入的分站
	// 4、判断购买数量是否符合商品服务返回的最大最小购买数量
	// 5、保存goodsId以及他对应的goodsInfo信息，供下面使用
	
	
	// 调用(address服务, getAddressByID方法)
	// 根据传入的地址ID，获取用户的详细地址信息
	
	
	// 调用库存服务(stock服务, getSaleStock方法)
	// 验证库存是否充足
	// 1、验证是否所有传入的商品，库存接口都有返回对应的库存，如果不是，return错误
	// 2、循环购买的商品ID，执行[商品ID-库房列表]goodsStock选择规则：
	//    1、如果是纯赠品，返回所有对应库存数量够的库房列表；如果都不够，返回库存量最大的库房列表，并且修改赠品数量为库存数量
	//		2、如果这个商品既有购买的也有赠品的，返回所有对应（购买数+赠品数）库存量够的库房列表；
	//			 如果都不够，就只返回所有对应（购买数）库存量够并且赠品库存最多的库房列表，并且修改赠品数量为库存数量；
	// 		3、经过上面的规则筛选后，如果有商品没有库房列表，并且商品是赠品，则抹掉赠品不影响下单，不是赠品则表示库存不足，return错误
	// 3、保留上面组装好的goodsStock，供后面使用
	
	
	
	// 如果选择了当日达，校验当日达规则(当前时间、分站)
	
	
	// 调用配送服务(shipping服务, getGoodsShippingInfos方法)
	// 1、调之前，执行下判断配送日期规则：
	//		1、非纯赠品：根据getGoodsInfo返回的商品配送日期取交集，(如果是礼盒，跟他明细的配送日期交集)，如果最终交集为空，return错误
	//		2、纯赠品：根据getGoodsInfo返回的商品配送日期取交集，如果是礼盒，跟他明细的配送日期交集，如果最终交集为空，return错误；
	//			 如果纯赠品和第一步的日期没有交集，则这个赠品不调配送服务，也没有从购买列表里抹掉，而是在后面的步骤抹掉
	//		3、根据日期交集(第一步算的)是否有当天，判断当日达规则
	// 2、调配送服务，获得[商品ID-库房配送规则]，获得所有商品的配送日期的交集，执行配送规则验证
	//		1、判断是否所有购买的商品都有库房配送规则，如果是纯赠品没有库房配送规则，则抹掉；不是纯赠品没有库房配送规则，则return错误
	//		2、根据前面调getSaleStock方法返回商品对应的库房列表，和从配送返回配送规则的库房列表，取交集，看是否所有商品都有库房
	//		3、循环取出这些库房的可配送日期，是否可指定日期，是否支持COD，是否考虑运力，供下面使用
	//		4、获得所有商品的配送日期的交集
	
	
	// 调用配送服务(shipping服务, getGoodsShippingInfos方法)(考虑运力)
	// 逻辑同上，复用了上面的代码，仅仅是只多考虑了运力，
	// 个人觉得上面如果最后的配送日期交集为空就是“商品不可同日达”，这边配送日期交集为空就是“运力不足”
	
	
	// 确定收货日期：
	// 1、如果入参里有传收货日期，那么判断它是否在上面算的日期列表中，并且是否支持COD，验证结单时间
	// 2、如果没有传收货日期，校验是否支持COD，然后在日期列表里取个最小的日期
	
	
	// 开始指定订单商品的库房和配送公司
	// 1、根据确定的日期和是否选择了COD,找出所有的库房和配送公司组合
	// 2、按照最少拆单原则,指定商品的库房和配送公司(选商品对应出现最多次数的库房，以及他对应的优先级最高的配送公司)
	// 3、记录下商品在本库房本配送公司下，是否考虑运力（供插入订单明细表字段时使用）
									
	
	// 调用促销服务(promotion服务，getPromotionInfo方法)
	// 1、调之前看如果有换购商品，先根据getGoodsInfo接口返回的参数判断促销类型是否换购、状态、范围
	// 2、调促销，根据促销接口出参，验证促销是否合法
	//		1、如果促销接口有返回普通商品异常列表，直接return错误
	//		2、如果促销接口有返回N元Y件商品异常列表，直接return错误
	// 3、根据促销返回的订单满减金额和其他满减金额，按比例拆分到每个商品上面
	// 4、根据促销返回的所有商品金额，循环相加计算订单总金额
	// 5、获得真实的赠品(验证促销赠品后的赠品)


	// 调用运费服务(shipping服务，getGoodsShippingFee方法)
	// 1、获得实际应收总运费、折扣后总运费、时效配送服务费。
	
	
	
	// 准备下单数据插入订单表订单明细表
	// 组装订单明细表数据(循环的促销返回的商品list)，拆分满减，记录库房、配送公司等其他信息，如果是礼盒，顺便组装它的明细数据
	// 组装订单表数据
	// 插入订单流水表数据
	// 并返回一些前台需要展示和推送的订单数据信息



}
